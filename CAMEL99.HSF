\   ____    _    __  __ _____ _    ___   ___
\  / ___|  / \  |  \/  | ____| |  / _ \ / _ \
\ | |     / _ \ | |\/| |  _| | | | (_) | (_) |
\ | |___ / ___ \| |  | | |___| |__\__, |\__, |
\  \____/_/   \_|_|  |_|_____|_____|/_/   /_/
\
\
\  _____ ___  ____ _____ _   _
\ |  ___/ _ \|  _ |_   _| | | |
\ | |_ | | | | |_) || | | |_| |
\ |  _|| |_| |  _ < | | |  _  |
\ |_|   \___/|_| \_\|_| |_| |_|
\
\ Copyright (c) 2017 Brian Fox
\ KOMOKA Ontario Canada
\ brian.fox@foxaudioresearch.ca
\ This program is free software; you can redistribute it and/or modify
\ it under the terms of the GNU General Public License as published by
\ the Free Software Foundation; either version 3 of the License, or
\ (at your option) any later version.
\ You should have received a copy of the GNU General Public License
\ along with this program.  If not, see <http://www.gnu.org/licenses/>.
\
\ The work derived from CAMEL Forth under the GNU General Public License.
\ CamelForth (c) 2009 Bradford J. Rodriguez.
\ Commercial inquiries for Camel Forth should be directed to:
\ 115 First St., #105, Collingwood, Ontario L9Y 4W3 Canada
\ or via email to bj@camelforth.com


\ History
\ Originally this was a cross-compiled as a 16 bit Camel Forth System for DOS
\ Started Sept 14, 2015      Version 1.0 completed Mar 23, 2016

\ Nov 29,2016  - Ported CAMEL FORTH V .1 to TI-99

\ ========================================================================
\                    *** CHANGES FROM V1.0 ***
\ ------------------------------------------------------------------------
\ Oct 7, 2017  - Version 1.9 includes POSTPONE, ;CODE and DOES>
\              - 99.2% ANS CORE compliant. Missing 1 word: ENVIRONMENT?

\              - change to CHARDEF in GRAFIX2.FTH
\                -Now uses pointer to data, not stack data
\              - S" now uses a string POOL at >2000
\              - HEAP memory system added. Starts at >2180
\              - Target loops now in separate file. (targloop.hsf)
\                - LEAVE has been implemented per CAMEL Forth method
\              - numerous speedups and size reductions in CODE words
\              - new word: ^C? scans keyboard for control C
\                - 4X faster than KEY?
\              - TMR! TMR@ let you use the 9901 timer for limit timing
\              - MS word uses the 9901 timer for accurate delays
\              - added :NONAME to improved compliance

\ Nov 18, 2017 - V1.96 Found ROM routine for Fnct 4 key test. Very fast!
\              - Removed ^C?.  Replaced with ?TERMINAL like TI-Forth

\ DEC 1, 2017  - V1.97 added smart MOVE word, put it in PLACE.

\ Requirements: XFC99.EXE, Cross-Compiler/Assembler  by Brian Fox

\ Credit where it's due:
\          Lessons from HSFORTH METACOMP program, by the late Jim Kalihan
\          Lessons on dictionary structure and number conversion from Camel Forth,
\          by Brad Rodriguez.
\          Lessons from Mark Wills on the TI-99 internals
\          Cross compiler by Brian Fox Canada

\ ========================================================================
\ O B J E C T I V E

\ This Forth Cross-compiler and Forth system were created for education.
\ The hope is that with the many comments included and some online
\ reference material a person can fully understand how a threaded Forth
\ cross-compiler works from the ground up.

\ ========================================================================
\ C A M E L   F O R T H   H E A D E R    S T R U C T U R E
\ by Brad Rodriguez  Ph.D.


\     D7           D0
\     +---------------+
\     |               |   byte 1      \ LINK FLD contains NFA of previous word
\     |-    link     -|
\     |               |   byte 2
\     +-------------+-+
\     |      0      |P|   byte 3     \ P - Precedence bit, equals 1 for an IMMEDIATE word
\     +-+-----------+-+
\     |S|   length    |   byte 4     \ S - Smudge bit, used to prevent FIND from finding this word.
\     +-+-------------+
\     |               |   byte 5
\     |-    name     -|
\     |               |   ... to byte N
\     ~~~~~~~~~~~~~~~~~
\     |               |   byte n+1
\     |-  code field -|
\     |               |
\     +---------------+
\
\ CamelForth header has 1 byte extra but gives clean access to fields.
\ Link - in CamelForth, points to the previous word's name field (length)

\ ========================================================================
\ B  F O X   C R O S S   C O M P I L E R  (XFC99) G O T C H A S

\ I had never written a cross-compiler and so this one has it's own way of operating.
\ In a nutshell all IMMEDIATE words and/or words that PARSE the input stream
\ during compile time start with the letter 'T'. I also added a COLON to 
\ the end of DEFINING words to help me remember that I am cross-compiling
\
\ This made it much simpler to make it all work because there can never
\ be a word collision between the HOST, the COMPILER or the TARGET vocabularies.

\ Here is the list of 'T' prefixed words you need to use instead of the 
\ standard Forth words in order to compile code with XFC99:

\ XFC99               Standard Forth
\ -----------       ----------------
\ TCHAR                CHAR
\ T[CHAR]              [CHAR]
\ TCOMPILE             COMPILE
\ T[COMPILE]          [COMPILE]
\ TLITERAL             LITERAL
\ TS"                   S"
\ T."                  ."
\ T,"                  ,"
\ T[   ]T              [  ]

\ CONSTANT:            CONSTANT
\ VARIABLE:            VARIABLE
\ CREATE:              CREATE
\

\ AND... one weird one is XIMMEDIATE is used for the IMMEDIATE TARGET
\ Forth words. (I just didn't like the look of TIMMEDIATE)

\ test for the cross-assembler
HEX
[undefined] XASSEMBLER  [if] cr ." TI-99 Cross Assembler not loaded" ABORT [then]

\ ========================================================================
\ M E M O R Y  C O N F I G U R A T I O N

\ In XFC99 we can use equates like we do in the XFC99 assembler with EQU.
\ Equates are replaced in the final code with a literal number and have
\ the advantage that the names are NOT included in the Forth dictionary.
\ This saves considerable space when building the Camel Forth kernel.

CROSS-COMPILING
HEX

       0FFF0   EQU EMEM    \ EMEM = "end of memory"
   EMEM 00F0 - EQU 'TIB    \ ADDRESS OF default Terminal Input Buffer
   EMEM 'TIB - EQU TIBSIZE

\ ========================================================================
\ Create FORTH stacks at upper end of TI-99 low memory block
HEX
       3F00     EQU SP0      \ FORTH parameter stack base address.
       SP0 FF + EQU RP0      \ FORTH return stack base address

\ ========================================================================
\       CAMEL99 memory map
\     +--------------------+ $FFFF end of memory
\     |          TIB       | $FF02
\     +--------------------+ $FF00
\     |                    |
\     |                    |
\     |                    |
\     |                    |
\     |                    |
\     |                    |
\     |                    |
\     |                    |
\     |    USER PROGRAM    |   24K program space
\     |                    |
\     +--------------------+
\     |                    |
\     |       CAMEL99      |
\     |       KERNEL       |
\     +--------------------+  $A000 (hi-RAM) Forth Dictionary begins here
\     |  MEM mapped device |
\     +--------------------+ $83FF
\     |  CPU hi-speed RAM  |
\     +--------------------+ $8300  Camel99 workspace registers and user variables
\     |      Cartridge     |
\     |      GROM/ROM      |
\     +--------------------+ $6000
\     |     Peripheral     |
\     |        ROMS        |
\     +--------------------+ $4000             --------
\     +vvvvvvvvvvvvvvvvvvvv+ $3FFE RP0            .
\     | return stack       |                      .
\     +vvvvvvvvvvvvvvvvvvvv+ $3F80 SP0            .
\     | parameter stack    |                      .
\     |                    |                      .
\     |                    |                      .
\     |                    |
\     |    HEAP MEMORY     |
\     |   ^^^^^^^^^^^^^    |                      .
\     |  (SCROLL BUFFER)   |                      .
\     |--------------------| $2100         8K low mem block
\     |   TI O/S USAGE     |
\     +--------------------+ $2000             --------
\     |                    |
\     |   CONSOLE ROMS     |
\     +--------------------+ $0000


\ ========================================================================
\ conditional compiling control

FALSE VALUE TOOLS                  \  tools compilation flag
FALSE VALUE DEBUGGING              \  debugging words compilation flag
FALSE VALUE FILES?

\ ========================================================================
\ C O D E   P R I M I T I V E S

[cc] cr .( Compile Forth Assembler primitives ...)  \ This is a talking comment.
                                                    \ It reports what's happending
                                                    \ during compilation
 INCLUDE CC9900\9900FAST.HSF

\ ========================================================================
\ RESOLVE CODE WORD FORWARD REFERENCES FOR CROSS-COMPILER

\ The words beginning with ' are place holders used by the cross-compiler.
\ At compile time these words compile their value into the TARGET code.
\ Below we give them the execution token (XT) of their respective ASM WORDS.

 T' EXIT    RESOLVES 'EXIT
     ENTR   RESOLVES 'DOCOL
 T' DOVAR   RESOLVES 'DOVAR
 T' LIT     RESOLVES 'LIT
 T' DOCON   RESOLVES 'DOCON
 T' DOUSER  RESOLVES 'DOUSER
 T' DODOES  RESOLVES 'DODOES
\ T' DLIT    RESOLVES 'DLIT

\ ========================================================================
\ T A R G E T   D E - C O M P I L E R
\ "TSEE" lets you de-compile Target words from within the HOST Forth
\ Great to confirm the compiler is making correct code.

CROSS-COMPILING
-1 [IF]
       INCLUDE CC9900\CCLIB\TSEE.HSF
[THEN]

\ ========================================================================
\ T A R G E T  S T A T E

TARGET-COMPILING

   VARIABLE: STATE       \ Create the variable in target space. We will use it as the Cross-compiler's state variable
                         \ TARGET variables function in the HOST Forth!

   STATE [CC] TO XSTATE  \ Now we take that address from the stack and store it in CROSS-COMPILER value called XSTATE
                         \ Now when we use XSTATE we will be toggling the value of STATE in the target memory
                         \ Why? When I did this I didn't know how best to make a cross-compiler


\ ========================================================================
\ C R O S S   C O M P I L E R   B R A N C H   A N D   L O O P   W O R D S
CROSS-COMPILING

INCLUDE CC9900\BRCHLOOP.HSF    \ it was simpler to keep this in a separate file


\                  ***  P R E -  A M B L E   E N D S   ***
\ /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\


\           T A R G E T   F O R T H   S Y S T E M   B E G I N S
\

\ ========================================================================
\ S Y S T E M   C O N S T A N T S

CROSS-COMPILING HEX
cr .( Constants and Variables...)

TARGET-COMPILING

\ Memory constants for CAMEL99

\ ASM/Equate       Forth Name
\ -----------      ------------
 'TIB     constant: TIB            \ address of terminal input buffer (TIB) in high memory
 SP0      constant: SP0            \ Parameter stack base address
 RP0      constant: RP0            \ Return stack base address
 TIBSIZE  constant: TIB#           \ bytes in terminal input buffer
\ 83C2    constant: AMSQ           \ disables misc. ISRs.  see TI-Tech pages on internet

\ Utility constants
\ in Forth, literal numbers take 4 bytes, constants use only 2 bytes
       0 constant: FALSE
      -1 constant: TRUE
       0 constant: 0
       1 constant: 1            
       2 constant: 2               \ not in the standard (weird)
       3 constant: 3
      -1 constant: -1
      20 constant: BL              \ blank character

\ _NEXT >HSRAM constant: 'NEXT     \ the multi-tasker needs the address of NEXT
\      _TSTAT constant: 'TSTAT     \ convert code label to Forth constant

\ ========================================================================
\ S Y S T E M / U S E R   V A R I A B L E S
\ CAMEL99 uses space after workspace for user vars.
\ User variables begin at >8320 for the primary Forth task

\ USER 0..1F are CPU workspace registers in CAMEL99
       0 USER: 'R0                 \ address of R0
       2 USER: 'R1
       4 USER: 'R2
       6 USER: 'R3
\       8 USER: 'R4
\       A USER: 'R5
\       C USER: 'R6
\       E USER: 'R7                 \ address of R7
\      10 USER: 'R8
\      12 USER: 'R9
\      14 USER: 'R10
\      16 USER: 'R11
\      18 USER: 'R12
\      1A USER: 'R13
\      1C USER: 'R14
\      1E USER: 'R15

      20 USER: TFLAG               \ TASK flag awake/asleep status
      22 USER: JOB                 \ Forth word that runs in a task
      24 USER: DP
      26 USER: HP
      28 USER: CSP
      2A USER: BASE
      2C USER: >IN
\      2E USER: 'EMIT              \ vector for char. output routine
\      30 USER: 'CR                \ vector for carriage return
\       32 USER: 'KEY               \ vector for key input  >8332
\      34 USER: 'TYPE              \ vector for block output
\      36 USER: 'PAGE              \ vector for screen clear
      38 USER: LP                  \ LEAVE stack pointer.
      3A USER: SOURCE-ID           \ =true if EVALUATE is running, false otherwise
      3C USER: 'SOURCE             \ WATCH OUT! This is 2variable, occupies 3C and 3E
\     3E USER: 'SOURCE2

\      40 USER: CURRENT
\      42 USER: CONTEXT
\      44 USER:
\      46 USER:                    \ last free space in hi speed RAM (PAD)

variable: LATEST                   \ LATEST returns the NFA (a counted string)

\ These system variables control cold starting the system
variable: ORGDP                    \ restore DP to this on COLD boot
variable: ORGLAST                  \ restore LATEST to this on COLD boot
variable: BOOT                     \ ADDRESS OF THE FIRST Forth word to run

\ screen control variables are addresses defined in file: 99EQU.HSF
\ See: 9900fast.hsf

\ ASM/Equate      Forth Name
\ -----------    ------------
  _OUT  constant: OUT                       \ counts chars since last CR (newline)
  _C/L  constant: C/L                       \ Chars per line (32 or 40 depending on VDP mode)
  _VROW constant: VROW                      \ current VDP row
  _VCOL constant: VCOL                      \ current VDP column
 _C/SCR constant: C/SCR                     \ chars per screen >300 or 3C0
   0018 constant: L/SCR                     \ 24 lines per screen on a TI-99

        variable: VMODE                     \ keeps track of the video mode we are in
        variable: VTOP                      \ top of video screen memory. defaults to 0
        variable: H                         \ pointer to Heap in TI-99 low memory (init to >2100)

\ TI-99 keyboard control memory locations
\ *ATTENTION* these constants define memory locations so they are actually VARIABLES :-)
 _CURSR constant: CURS                      \ holds CURSOR character for KEY
   8375 constant: KVAL                      \ GPL KSCAN outputs ascii value here. >FF if no key pressed
   83D4 constant: KTP                       \ copy of VDP R1. TI-99 system stores the keyboard type here
   83C6 constant: KUNIT#                    \ keyboard unit# (CAMEL99 uses MODE 5, BASIC MODE)

        variable: L0    3 TCELLS TALLOT     \ LEAVE stack used to resolve nested LEAVEs (4 LEAVEs max)
?stk
\ ==============================================
\ F O R T H   M E M O R Y   A L L O C A T I O N
[cc] cr .( Hi-level FORTH Primitives...)

TARGET-COMPILING
: ALLOT     ( n --)    DP +!  ;     \ allocate dictionary space
: HERE  ( -- addr)     DP @ ;       \ 4 bytes but slower
: ALIGN     ( -- )     HERE ALIGNED DP ! ;
: ,         ( n --)    HERE !   2 ALLOT ;
: C,        ( c --)    HERE C!  1 ALLOT ;

: #PAD      ( -- addr) HERE 22 + ;  \ space for number formatting (worst case: 32 digits & minus sign) GROWS DOWNWARD
: PAD       ( -- addr) HERE 24 + ;  \ general purpose buffer in un-allocated space grows UPWARD

: >BODY     ( addr -- addr') CELL+ ;

\ : COMPILE,  ( n --)  ,  ;                \ for ITC Forth this is the same as , (comma compiler)

: COMPILE   ( -- )  R> DUP CELL+ >R @ , ;  \ append inline execution token

: IMMEDIATE  ( --)  01 LATEST @ 1- ( -- imm-fld) C! ;  \ set the precedence BIT in the last word defined

: LITERAL    ( n -- n|~)  STATE @ IF  COMPILE LIT  , THEN ;  XIMMEDIATE

: ]          ( -- ) STATE ON  ;  XIMMEDIATE \ turn on the compiler
: [          ( -- ) STATE OFF ;  XIMMEDIATE \ turn off the compiler


[cc] cr .( Stack primitives ...)  [tc]
\ ========================================================================
\ S T A C K   P R I M I T I V E S

\ If Assembler CODE versions are not in the file 9900FAST.HSF
\ this code will automagically compile the Forth version instead.
\ Comment out these words in the 9900FAST.HSF file to trade-off size and speed
\ In some cases CODE versions are bigger, but are always faster.

[UNDEFINED] ?DUP  [IF] : ?DUP  ( w -- w w, 0 ) DUP 0> IF DUP THEN ;         [THEN] \ smaller and faster in assembler
[UNDEFINED] NIP   [IF] : NIP   ( w w -- w )    SWAP DROP ;                  [THEN] \ smaller and faster in assembler
[UNDEFINED] TUCK  [IF] : TUCK  ( w1 w2 --  w2 w1 w2 ) SWAP OVER ;           [THEN]

[UNDEFINED] ROT   [IF] : ROT   ( w1 w2 w3 -- w2 w3 w1 ) >R SWAP R> SWAP ;   [THEN] \ 4 bytes bigger in assembler
[UNDEFINED] -ROT  [IF] : -ROT  ( n1 n2 n3 -- n3 n1 n2 ) SWAP >R SWAP R> ;   [THEN] \ 4 bytes bigger in assembler
[UNDEFINED] 2DROP [IF] : 2DROP ( w w  -- ) DROP DROP ;                      [THEN]
[UNDEFINED] 2DUP  [IF] : 2DUP  ( w1 w2 -- w1 w2 w1 w2 ) OVER OVER  ;        [THEN]

\ : 2>R    ( w w --)  >R >R ;                     \ 2x bigger in ASSEMBLER
\ : 2R>    ( -- w w ) R> R> ;                     \ 2x bigger in ASSEMBLER

[UNDEFINED] 2OVER [IF] : 2OVER  ( d d2 - d d2 d)     2>R 2DUP  2R> 2SWAP ;  [THEN] \ 2x bigger in ASSEMBLER
[UNDEFINED] BOUNDS [IF] : BOUNDS  ( adr n -- adr2 adr1 ) OVER + SWAP ;      [THEN]
\ [UNDEFINED] 2ROT  [IF] : 2ROT   ( d d2 d3 - d2 d3 d) 2R> 2SWAP 2R> 2SWAP ;  [THEN]

\ ========================================================================
\ C O M P A R I S O N   O P E R A T O R S

[cc] cr .( Comparison)

TARGET-COMPILING

\ : NOT           ( w -- ? )  0= ;

\ U< is 6 bytes in ASSEMBLER, 20 in Forth
[UNDEFINED] U<  [IF] : U<  ( u u -- ? ) 2DUP XOR 0< IF  NIP 0< EXIT THEN - 0< ; [THEN]

\ CODE versions of these words take 6 bytes. Forth versions take 4 bytes, but are slower
[UNDEFINED] U>  [IF] : U>  ( w w -- ?)  U< 0= ;                                 [THEN]
[UNDEFINED] 0>  [IF] : 0>  ( w w -- ? ) 0< 0= ;                                 [THEN]
[UNDEFINED] <>  [IF] : <>  ( w w -- ? ) =  0= ;                                 [THEN]
[UNDEFINED] <   [IF] : <   ( w w -- ? ) >  0= ;                                 [THEN]

[UNDEFINED] MAX  [IF] : MAX   ( n n -- n ) 2DUP      < IF SWAP THEN DROP ;      [THEN] \ 2X bigger in Forth
[UNDEFINED] MIN  [IF] : MIN   ( n n -- n ) 2DUP SWAP < IF SWAP THEN DROP ;      [THEN] \ 2X bigger in Forth

[UNDEFINED] UMIN [IF] : UMIN ( u1 u2 -- u )  2DUP U> IF SWAP THEN DROP ;        [THEN] \ 2X bigger in Forth
[UNDEFINED] UMAX [IF] : UMAX ( u1 u2 -- u )  2DUP U< IF SWAP THEN DROP ;        [THEN] \ 2X bigger in Forth

\ Code  WITHIN is 20 bytes, speed is 102 cycles (9x faster)
\ Forth WITHIN is 12 bytes, speed is 894 cycles due to NEXT
[UNDEFINED] WITHIN [IF] : WITHIN ( u lo hi -- t ) OVER - >R - R> U< ;           [THEN]

\ ========================================================================
\ M I X E D  (32BIT/16BIT)   M A T H   O P E R A T I O N S
\ Some double-precision arithmetic operators are needed to implement
\ ANSI numeric conversion in CAMEL Forth.

\ *****
\ NOTE:
\ Removed signed multiplication and division operators to save space.
\ Substituted TMS9900 machine multiplication and division.
\ You can load CAMEL Forth signed operators from file SIGNED.HSF in the
\ LIB folder for compatability with ANS/ISO Forth as needed.
\ I also replaced M* with UM* to save space
\ This also improves the speed of the kernel generally.
\ *****

: */MOD       ( n1 n2 n3 -- n4 n5)  >R UM* R> UM/MOD ;   \ n1*n2/n3, rem&quot

: S>D         ( n -- d)     DUP 0< ;

: /MOD        ( n1 n2 -- n3 n4)  >R S>D R> UM/MOD ;      \  divide/remainder

[UNDEFINED] * [IF] : *  ( n n -- n)  UM* DROP ;  [THEN]  \ same size in ASM, 4 bytes, take the speed

: /           ( n n -- n)   /MOD NIP  ;     \ these are smaller than CODE words. (4 bytes each)
: MOD         ( n n -- n)   /MOD DROP ;
: */          ( n n n -- n) */MOD NIP ;

\ ========================================================================
\ S T R I N G   T H I N G S

TARGET-COMPILING
: MOVE        ( src dst n -- )  \ version for 1 address unit = 1 char
              >R
              2DUP SWAP DUP
              R@ +                \ -- ... dst src src+n
              WITHIN
              IF    R> CMOVE>         \ src <= dst < src+n
              ELSE  R> CMOVE  THEN ;  \ otherwise

\ CAMEL Forth calls this ">COUNTED"
: PLACE       ( src n dst -- ) 2DUP C! CHAR+ SWAP MOVE ;

\  /STRING is a CODE word in CAMEL99.
\ Only 6 bytes in ASM vs 10 bytes in Forth and is 10x faster
\ : /STRING   ( c-addr1 u1 n -- c-addr2 u2 ) ROT OVER + -ROT - ;

\ compile a stack string into memory with the count (Gforth)
: S,         ( c-addr u -- ) HERE OVER CHAR+  ALLOT PLACE ALIGN ;


\ ========================================================================
\ H E A D E R   N A V I G A T I O N

TARGET-COMPILING
: NFA>LFA       ( nfa -- lfa)    3 - ;
: NFA>CFA       ( nfa -- cfa )  COUNT + ALIGNED  ;

\ smudge bit control in the Camel Forth
: HIDE          ( -- )  LATEST @ ( nfa) DUP C@ 80 OR  SWAP C! ;
: REVEAL        ( -- )  LATEST @ ( nfa) DUP C@ 7F AND SWAP C! ;

FORTH cr ." Parsing..."
\ ========================================================================
\ P A R S E   W O R D

\ courtesy Brad Rodriguez,  My favourite FORTH Canadian
TARGET-COMPILING

: SOURCE      ( -- adr n) 'SOURCE 2@ ;    \ return current input buffer. Common factor, save space

: ADR>IN      ( c-addr' --  )             \ set >IN to offset to given adr
              SOURCE                      \ -- Cadr' adr n
              -ROT -                      \ -- n adr'-adr
              MIN  0 MAX                  \ -- n'
              >IN ! ;

: PARSE       ( char -- c-addr n)         \ word delim'd by char
              SOURCE >IN @ /STRING        \ -- c adr n
              OVER >R ROT SCAN
              OVER SWAP
              IF CHAR+ THEN               \ skip trailing delim. if any
              ADR>IN                      \ advance >IN   -- adr"
              R> TUCK - ;

: PARSE-NAME  ( char -- c-addr n)         \ Forth 2012 word
              DUP SOURCE >IN @ /STRING    \ -- c c adr n
              ROT SKIP                    \ -- c adr' n'
              DROP ADR>IN PARSE ;         \ -- adr" n"

: WORD        ( char -- c-addr)           \ word delim'd by char
              PARSE-NAME                  \ -- adr" n"
              HERE                        \ --
              2DUP C! CHAR+ SWAP CMOVE    \ expanded this for a compiling speed
              HERE                        \ -- a
              BL
              OVER COUNT + C! ;        \ append trailing blank

\ ========================================================================
\ Parse input stream until '"' and compile into memory

: ,"          ( -- ) T[CHAR] " PARSE  S,  ;  XIMMEDIATE


FORTH cr ." CAMEL FORTH Number conversion"
\ ========================================================================
\ S T R I N G  T O  N U M B E R   C O N V E R S I O N

[CC] HEX

TARGET-COMPILING
: DIGIT?     ( char -- n -1)                \ if char is a valid digit
\            (      -- x  0 )               \ if char is not valid
              DUP 39 > 100 AND +            \ silly looking
              DUP 140 > 107 AND -  30 -     \ but it works!
              DUP BASE @ U< ;               \ 36 bytes

: ?SIGN       ( adr n -- adr' n')           \  f  get optional sign
\ advance adr/n if sign; return NZ if negative
              OVER C@                       \ -- adr n c
              2C - DUP ABS 1 = AND          \ -- +=-1, -=+1, else 0
              DUP IF CHAR+                     \ -- +=0, -=+2
                     >R 1 /STRING R>        \ -- adr' n' f
              THEN ;

: UD*         ( ud1 u2 -- ud3)              \ 32*16->32 multiply
              DUP >R * SWAP R> UM* ROT + ;  \ simplified with * BF.

: >NUMBER     ( ud adr u -- ud' adr' u' )   \ convert string to number
              BEGIN  DUP
              WHILE
                  OVER C@ DIGIT? 0=
                  IF   DROP EXIT
                  THEN
                  >R 2SWAP BASE @ UD*
                   R> M+ 2SWAP 1 /STRING
              REPEAT ;

: ?NUMBER     ( c-addr -- n -1 )            \ string->number
\ ;Z                   -- c-addr 0          \ if convert error
              DUP  0 0 ROT COUNT            \ -- ca ud adr n
              ?SIGN >R  >NUMBER             \ -- ca ud adr' n'
              IF   R> 2DROP 2DROP FALSE     \ -- ca 0   (error)
              ELSE  2DROP NIP R>
                 IF NEGATE THEN TRUE         \ -- n -1   (ok)
              THEN ;

\ ========================================================================
\ H A R D W A R E   O R   S / W   T I M E R

-1 [IF]
        [CC] include cc9900\cclib\ticktock.hsf  \ TMS9901 timer interface
[ELSE]

      : MS  ( n -- ) 8* 0 ?DO PAUSE LOOP ;      \ simple timer,approximately 1 msec
                                                \ 8000 MS max
[THEN]


-1 [IF]
\ ========================================================================
\ S I M P L E   S O U N D  I N T E R F A C E
TARGET-COMPILING

: SND!       ( c -- ) 8400 C!  ;            \ write a byte to address of TMS9919 chip

: BEEP       ( -- )
             80 SND! 5 SND!                 \ precalulated values for OSC1 1328Hz
             91 SND!                        \ turn on OSC1 at -2 dB level
             AA MS                          \ Delay ~ 170 mS
             9F SND! ;                      \ turn off OSC1

: HONK       ( -- )
             81 SND! 20 SND!                \ precalulated values for OSC1 218Hz
             90 SND!                        \ turn on OSC1 at 0 dB level
             AA MS                          \ Delay ~ 170 mS
             9F SND! ;                      \ turn off OSC1

[ELSE]

\ =============== O R ================
\ B I G   S O U N D  I N T E R F A C E

 [CC] include cc9900\cclib\sound.hsf

 [THEN]

\ ========================================================================
\ V D P  S C R E E N   D R I V E R
FORTH cr .( Console output)
\ Most of the video driver is in Forth. We use Assembler to update the
\ screen position variables mostly to save space but it is faster too.
\ We also write the character to the screen in ASM using VC!.

TARGET-COMPILING
\ pronounced "SEE-PER-ELL-STORE"
: C/L!       ( C/L -- )         \ "chars per line store"
             DUP C/L !          \ record the chars per line in C/L variable
             L/SCR *  C/SCR ! ; \ multiply by lines/scr, and record in C/SCR

\ -----------------------------------------------------------------------
\ Scrolling has been implemented in Forth to show how factoring out 3 key
\ routines ( VREAD, FILL, VWRITE) in Assembler can deliver great speed
\ without needing to write everything in Assembler.

\ Algorythm:
\ 1. read the entire screen into a RAM buffer in unallocated HEAP memory
\ 2. add an extra blank line to the end of the BUFFER
\ 3. Write the buffer back to top of VDP screen BUT starting at 2nd line
\    and including the new blank line.

\ Advantage: we erase the bottom line in RAM MUCH faster than in VDP RAM
\ Disadvantage: we need a big buffer (1k bytes in 40 column mode)
\               so we use un-allocated HEAP memory.

[cc] HEX [tc]

\ : GETXY     ( -- col row ) VCOL 2@  ;   \ returns column & row
: AT-XY       ( col row -- ) VCOL 2! ;    \ VCOL,VROW are adjacent so we can 2!

: SCROLL      ( -- ) \ ** 68 bytes
              PAUSE
              VTOP @ H @  C/SCR @ VREAD       \ copy screen from >0000 into buffer at 2100
              H @  C/SCR @ +  C/L@  BL FILL   \ create an extra line blanks (spaces) at end of buffer
              H @  C/L@ +                     \ calc. the address of 2nd line
              ( adr) VTOP @ C/SCR @ VWRITE     \ write 2100 back to screen from 2nd line to top of screen
              0 17 AT-XY  ;                    \ update CURSOR position

[cc] DECIMAL [tc]

\ VDP OUTPUT WORDS
: ?SCROLL     ( -- )  VROW @ 23 > IF SCROLL THEN ; \ if VROW is past last row ... scroll!

: CR          ( -- )      <CR>  ?SCROLL ;
: EMIT        ( char -- ) VEMIT ?SCROLL ;

TARGET-COMPILING
CODE: IC@     CODE[ I C@ ] NEXT, END-CODE

: TYPE        ( adr cnt --)   \ normal version of TYPE calls EMIT
              BOUNDS DO  IC@  EMIT LOOP ;


: PAGE        ( -- )                           \ Forth's word for TI-Basic's "CALL CLEAR"
              VTOP @ C/SCR @ BL VFILL          \ fill VDP memory from address 0 with blanks
              0 0 AT-XY ;

: SPACE     ( -- )   BL EMIT ;                 \ EMIT a blank. (BL)
: SPACES    ( n -- ) 0 MAX  0 ?DO SPACE LOOP ;

\ ========================================================================
\ S T R I N G   L I T E R A L S
[cc] HEX [tc]

: <S">        ( caddr -- addr len addr')
               COUNT 2DUP + ALIGNED ;          \ common factor in next words

: (S")        ( -- c-addr u)  R> <S"> >R ;     \ run-time action of S"

: (.")        ( -- )  R> <S"> >R TYPE ;        \ runtime for ."

\ ========================================================================
\ Re-solve CROSS-COMPILER Forward reference for '(S") and '(.")
CROSS-COMPILING

T' (.")  RESOLVES '(.")
T' (S")  RESOLVES '(S")


[cc] cr .( Character input)
\ ========================================================================
\ C H A R A C T E R   I N P U T

TARGET-COMPILING

\ : KBRD       ( c -- ) 3 - KUNIT# C! ;        \ set the keyboard number.

: KEY?       ( -- ? ) 0 (KEY?) ;               \ test if key pressed

: KEY        ( -- char)                        \ simple non-repeating KEY
              BEGIN
                PAUSE                          \ multi-tasking switch
                CURS@ VPOS VC!                 \ show the flashing cursor
                0500 (KEY?)                    \ 0500 is BASIC keyboard
              UNTIL                            \ wait for key press
              KVAL C@                          \ fetch char from KSCAN buffer
              BL VPOS VC! ;                    \ erase cursor

\ : KEY   ( -- ) 'KEY @ EXECUTE ;                \ vectorable KEY

: BS  ( n --)  VCOL @ SWAP -  0 MAX VCOL ! ;   \ do 'n' backspaces.

\ High level: input/output                     (c) 31mar95 bjr
: ACCEPT      ( c-addr +n -- +n')              \ get line from terminal
              OVER + 1- OVER
              BEGIN  KEY DUP 0D <>             \ assumes we use PASCAL keybrd (#4)
              WHILE
                DUP EMIT
                DUP 8 =                        \ test for back-space character
                IF   DROP 1-  >R OVER R> UMAX  \ move the buffer pointer back
                     2 BS SPACE  1 BS          \ BF mod: handle backspace on the Video screen

                ELSE OVER C!  CHAR+ OVER UMIN
                THEN
              REPEAT
              DROP NIP SWAP -  ;

[cc] cr ." Number printing"
\ ======================================================================
\ N U M B E R   T O   S T R I N G   C O N V E R S I O N

\ Forth number conversion shows the elegance of Charles Moore's
\ way of thinking.  At a glance it is hard to understand how
\ these words work. But read the comments and the code in the order
\ shown to see how they build on each other.
\ With these simple words you can create arbitrary number formatting in 114 bytes!
\ Numeric conversion is done least significant digit first, so
\ the output buffer is built backwards in memory at #PAD.

TARGET-COMPILING
: UD/MOD      ( ud1 u2 -- u3 ud4)
         >R 0 R@ UM/MOD -ROT R> UM/MOD ROT  ;             \ 32/16->32 divide

: HOLD   ( char -- )        -1 HP +!  HP @ C! ;               \ decr. HOLD pointer HP, Store char at the address contained in HP
\ : >DIGIT ( n -- c)          DUP 9 > 7 AND + 30 + ;          \ convert n to ascii digit c (*Moved to ASM word because it is in a loop)
: <#     ( --)              #PAD HP ! ;                       \ initialize Hold Pointer to end of the number buffer (#pad)
: #      ( ud1 -- ud2)      BASE @ UD/MOD ROT >DIGIT HOLD ;   \ convert 1 digit & store at HP, return remainder
: #S     ( ud1 -- ud2)      BEGIN # 2DUP OR  0= UNTIL ; \ convert all digits in ud1. ud2 will be 0 (the remainder)
: #>     ( ud1 -- c-addr u) 2DROP HP @ #PAD OVER - ;          \ return a stack string (address, length)  of the converted number
: SIGN   ( n -- )           0< IF T[CHAR] -  HOLD THEN ;      \ if 'n'<0  add '-' char  string created in #PAD
\ : UD.    ( d -- )   <#  #S  #>  TYPE SPACE ;                \ print 'd' as 32 bit un-signed integer
\ : U.     ( u -- ) S>D UD. ;                                 \ print 'n' as 16 bit un-signed integer
: U.     ( u -- )         0  <#  #S  #>  TYPE SPACE ;         \ print 'u' as an un-signed integer (the '0' converts u to a double(32bit) int)
: .      ( n -- ) DUP ABS 0  <# #S ROT SIGN #> TYPE SPACE ;   \ print n as signed insteger

\ ========================================================================
\ M I S C E L L A N E O U S
\
TARGET-COMPILING
: LASTCFA     ( -- cfa) LATEST @ NFA>CFA ; \ *new* return the CFA of the newest word in the dictionary
: RECURSE     ( -- )  LASTCFA ,  ; XIMMEDIATE

: DECIMAL     ( -- ) 0A BASE ! ;
: HEX         ( -- ) 10 BASE ! ;

\ ========================================================================
\ I N T E R P R E T E R   F O R W A R D   R E F E R E N C E
\ Standard Forth does not allow us to use a word that is not already defined.
\ BUT we need the word INTERPRET to be defined so we can define "QUIT" below.
\ This is a simple way to do a forward reference.

  VARIABLE: 'INTERPRET   \ container for the execution token (XT) of <INTERPRET>

\ With this definition the Forth compiler will be happy to define QUIT below.
\ All QUIT needs is a word called INTERPRET. It does not care that it is not ready to work yet.

: INTERPRET    ( addr len -- )  'INTERPRET @ EXECUTE ;       \ fetch the XT and pass to execute

\ **later in the code we MUST store an XT in 'INTERPRET or the system will crash

\ ========================================================================
\ Q U I T :  The  O U T E R   I N T E R P R E T E R

\ this is the Forth REPL (read,evaluate,print loop)
: QUIT         ( -- )
               L0 LP !                                       \ init LEAVE stack pointer LP
               RP0 RP!  [                                    \ RESET RSTACK & STATE
               BEGIN
                  TIB DUP TIB# ACCEPT SPACE INTERPRET        \ accept some typing into terminal input buffer
                  STATE @ 0= IF  T."  ok" cr THEN            \ if we are not compiling print OK
               AGAIN ;

: EVALUATE     ( c-addr u -- j*x)                            \ interpret a stack string
               SOURCE-ID ON                                  \ ANS standard says to set SOURCE-ID to true
               SOURCE 2>R  >IN @ >R                          \ save the source & >IN on the return stack
               INTERPRET                                     \ interpret the new string
               R> >IN !  2R> 'SOURCE 2!                      \ restore source & >IN
               SOURCE-ID OFF ;

\ ========================================================================
\ E R R O R   H A N D L I N G
\
: ABORT       ( -- ) HONK SP0 SP! ( ?CLOSE) CR QUIT ;
: ?ABORT      ( f c-addr u --) ROT IF T." ? " TYPE ABORT THEN 2DROP ;
: ?FIND       ( ? -- )       0=    TS" Not found"      ?ABORT ;
: ?PAIRS      ( n1 n2 --)     -    TS" Unpaired"       ?ABORT ;
: ?COMP       ( -- ) STATE @ 0=    TS" Compile only"   ?ABORT ;
: ?EXEC       ( -- ) STATE @       TS" Interpret only" ?ABORT ;
: ?CSP        ( -- ) SP@ CSP @ -   TS" Unfinished"     ?ABORT ;
: ?STACK      ( -- ) SP0 2- SP@ U< TS" Empty stack"    ?ABORT ;

: !CSP        ( -- ) SP@ CSP ! ;  \ record stack position in CSP variable
                                  \ (for error checking)

\ ========================================================================
\ S T R I N G   L I T E R A L
\ ISO Forth '94 version. Compile only
: S"           ( -- )
               ?COMP T[CHAR] " PARSE  COMPILE (S")  S, ; XIMMEDIATE

: ABORT"      ( i*x 0  -- i*x)    \ R: j*x -- j*x  x1=0
              ?COMP  T[COMPILE] S"  COMPILE ?ABORT ; XIMMEDIATE

\ ========================================================================
\ F O R T H   2 0 1 2   F I L E - A C C E S S   W O R D   S E T

CROSS-COMPILING

FILES? [IF] INCLUDE CC9900\ISOFILES.HSF  [THEN]

[cc] cr .( FIND )
\ ========================================================================
\ F I N D   A   F O R T H   W O R D
\ CAMEL99 uses a fast code word called (FIND) to search the dictionary
\ it over 4 times faster than using S= and hilevel Forth words

TARGET-COMPILING
: FIND  \  c-addr --  caddr  0  if not found
\                     xt  1  if immediate,
\                     xt -1  if "normal"
                      LATEST @ (FIND) ; \ start search with the last word defined


\ ========================================================================
\ D I C T I O N A R Y   S E A R C H

TARGET-COMPILING

: '           ( -- xt) BL WORD FIND ?FIND ;

: [COMPILE]   ( -- ) ?COMP  '   ,   ;  XIMMEDIATE

: [']         ( -- <name> ) ?COMP  '  T[COMPILE] LITERAL ; XIMMEDIATE

: POSTPONE      ( <name> -- )
                ?COMP
                BL WORD FIND DUP ?FIND    \ abort if not found in dictionary
                0< IF   COMPILE COMPILE   \ 0< means non-immediate word. need COMPILE
                   THEN  , ; XIMMEDIATE   \ compile the CFA into the definition

\ =========================================================================
\ convert ascii char to a number
: CHAR        ( -- <c>) BL WORD CHAR+  C@ ;
: [CHAR]      ( -- <c>) ?COMP CHAR T[COMPILE] LITERAL ; XIMMEDIATE

\ ========================================================================
\ I / O   R E - D I R E C T I O N

\ : CONSOLE     ( -- )  ['] <emit> 'EMIT ! ;


\ ========================================================================
\ T E X T   O U T P U T

: .(          ( <text> -- ) ?EXEC  T[CHAR] ) PARSE TYPE ; XIMMEDIATE

: ."          ( <text> -- ) ?COMP COMPILE (.")  ,"  ; XIMMEDIATE

[CC] cr ." Interpreter/compiler loop"
\ ========================================================================
\ I N T E R P R E T E R  /  C O M P I L E R

TARGET-COMPILING

: <INTERPRET>  ( i*x c-addr u -- j*x )    \ ; ref. dpANS-6, 3.4 The Forth Text Interpreter
               'SOURCE 2!  >IN OFF
               BEGIN  
                 BL WORD DUP C@
               WHILE            \ -- caddr
                  FIND                                \ -- xt 0/1/-1
                  ?DUP IF                             \ -- xt 1/-1
                       CHAR+ STATE @ 0= OR            \ IMMED  or interp?
                       IF EXECUTE ELSE , THEN         \ execute or compile, that's all there is
                  ELSE                                \ -- textadr
                       ?NUMBER
                       IF  t[COMPILE] LITERAL         \ converted ok
                       ELSE COUNT ?ABORT              \ error. print bad word & ABORT
                       THEN
                  THEN
                  ?STACK
               REPEAT
               DROP ;

\ ========================================================================
\ R E S O L V E   F O R W A R D   R E F E R E N C E
\ remember how we fooled the compiler?
\ Here is finish off the process.

CROSS-COMPILING

\ to get at stuff in the TARGET memory we us the Forth words '
\ which looks up the code field address of a word,
\ and ! which stores a number in an address.

\ BUT we have to use the TARGET COMPILER versions that are T' and T!

 T' <INTERPRET>  'INTERPRET ( -- addr variable) T!

\ ======================================================================
\ T I - 9 9   T E X T   M O D E   C O N T R O L
TARGET-COMPILING

: TEXT      ( -- )
             28 C/L!                       \ 40 chars/line, which re-calcs the screen variables too
             F0 DUP KTP C!                 \ TI KSCAN re-writes VReg1 with whatever is in this byte.
       ( -- F0) 01 VWTR                    \ VDP register 1  bit3 = 1 sets the TEXT Mode
              0 06 VWTR                    \ no sprite descriptor table is set for TEXT mode
             20 07 VWTR                    \ VDP register 7 = 2,0 med. green on transparent
             2 VMODE !                     \ record the mode we are in
             PAGE ;                        \ "CALL CLEAR" ;-)


\ ========================================================================
\ D I C T I O N A R Y   C R E A T I O N
\ Header creates a text string in memory that is linked back to the
\ last word that was defined in the Forth dictionary.

: HEADER
            LATEST @ ,                     \ record the LATEST NFA as the LINK in this new word
            0 C,                           \ create the immediate field  1 BYTE
            HERE LATEST !                  \ update the LATEST variable to this new definition's NFA
            BL WORD C@ CHAR+ ALLOT         \ read a space delimited string from the input stream and compile into memory
            ALIGN ;

\ ========================================================================
\ T A R G E T   S Y S T E M   D E F I N I N G   W O R D S
\ Believe it or not this is now all it takes to make Forth data types

\                    text    runtime-action   parameter
\ -------------------------  --------------- -----------
: CONSTANT  ( n --)  HEADER  COMPILE DOCON          , ; \ the comma is a number compiler, remember?
: USER      ( n --)  HEADER  COMPILE DOUSER         , ; \ the byte offset from workspace pointer
: CREATE    ( -- )   HEADER  COMPILE DOVAR            ; \ create does not have a parameter by default
: VARIABLE  ( -- )   CREATE                       0 , ; \ variables put zero in their parameter field when created

\ had to use the literal address of ENTR ($839E) to make this work.
: (:NONAME) ( -- )   839E ,  HIDE  ]  ;   \ common to ':' and ':NONAME'

\ ========================================================================
\ D O E S   S U P P O R T
: (;CODE)
         R>                        \ pops the adrs of the machine code
         LASTCFA                   \ gets the CFA of the latest word
         !  ;                      \ stores the machine code address in the Code Field

: DOES>  ( -- )                    \ change action of latest def'n
        COMPILE (;CODE)
        06A0 , T['] DODOES ,       \ machine code for:  BL @DODOES
        ; XIMMEDIATE

\ ========================================================================
\ ADD-ONS
 [CC] include cc9900\cclib\tools.hsf
 [CC] include cc9900\cclib\grafix2.hsf
\ [CC] include cc9900\cclib\groms.hsf
\ [CC] include cc9900\cclib\UGPL-LNK.HSF
\ [CC] include cc9900\tifile\filesys.hsf
\ [cc] include cc9900\cclib\MULTI99.hsf   ( conventional Forth tasker)
\ [cc] include cc9900\cclib\MTASK99.hsf   ( workspace switch tasker)

: DUP@.  ( adr - adr n)  ASM[ TOS PUSH,  *TOS TOS MOV,  ]ASM  . ;

\ =======================================================================
\ T E S T   C O D E   G O E S   H E R E
\ if you want to add any other code it must go before target branch compilers

TARGET-COMPILING
\ VARIABLE:  X
\ : DUP@   ASM[ TOS PUSH,  *TOS TOS MOV,  ]ASM  ;
\ : DUP@2  INLINE[ DUP @ ] ;

\ :  *+    INLINE[ * + ]  ;
\ : ^2   INLINE[ DUP * ]  ;

\ =======================================================================
\ LOOPS AND BRANCH COMPILERS FOR FINAL SYSTEM
[CC] CR .( if then else begin again until while repeat do leave loop...)

include cc9900\cclib\targloop.hsf  \ these compile code on the TARGET system



\ =======================================================================
\ Init functions
\ 1. CREATE the FORTH VIRTUAL MACHINE when CAMEL99 starts
\ 2. copy code from HSPRIMS to HSTART($8388)
\ 3. Set the Forth IP to address of BOOT variable

CROSS-ASSEMBLING

CODE: INIT    WRKSP0 LWPI,

              SP  SP0  LI,
              RP  RP0  LI,
              R10 NEXT2 LI,

              R0 HSprims LI,
              R1 HSstart LI,
@@1:         *R0+ *R1+ MOV,
              R1 HSend CMPI,
              @@1 JNE,

              IP  BOOT  LI,
              *R10 B,
              END-CODE

[CC] HEX
\ =======================================================================
\ B O O T   U P   C O D E
\ cold inits H to >2100.  2100..24E0 is scroll buffer,
TARGET-COMPILING
: COLD        80 83C2 C!
              ORGDP @ DP !
              ORGLAST @ LATEST !
              2100 H !
              HEX
              TMR!
              3 KUNIT# C!
              TEXT
              BEEP
              T." CAMEL99 MultiForth V1.97    B Fox 2017"
              CR QUIT ;

\ =======================================================================
\ define comment words
TARGET-COMPILING
: (         T[CHAR] ) PARSE 2DROP  ; XIMMEDIATE
: \                 1 PARSE 2DROP ;  XIMMEDIATE

[CC]
\ ******************************************************************
\ ***    FROM HERE ON WE CANNOT PUT COMMENTS INLINE WITH CODE    ***
\ ******************************************************************
\ ========================================================================
\ C O L O N   C O M P I L E R

\ These are the last definitions but they allow us to extend the TARGET
\ Forth system with Source code


\ To avoid name conflicts we use X: & ;X to create the TARGET system ':' and ';'
TARGET-COMPILING
 X: :         !CSP  HEADER (:NONAME)  ;X

 X: :NONAME    HERE  !CSP  (:NONAME)  ;X

 X: ;     [  REVEAL  COMPILE EXIT  ?CSP   ;X  XIMMEDIATE

[CC]
\           F O R T H   S Y S T E M   C O D E   E N D S
\ /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
cr ." Forth Kernel compiled completely"


\ ========================================================================
\  P A T C H   T H E   T A R G E T  S Y S T E M   V A R I A B L E S

\ Set the target system's LATEST variable (in mirror vocabulary)
\ to the last WORD compiled

CROSS-COMPILING
         XLATEST @ DUP [TC]   LATEST T!
                              ORGLAST T!

CROSS-COMPILING
\ set TARGET Forth's DP variable to the same address as the cross-compiler (THERE)
\ also copy it into the ORGDP variable used for cold re-starts

         THERE DUP DP T!
                   ORGDP T!
         DECIMAL 10 MIRROR BASE T!
[cc]
\ ========================================================================
\ P A T C H   T A R G E T   I M A G E

\ Update the filename, boot-address and BOOT word in the TARGET MEMORY IMAGE

         FILENAME: CAMEL99
         T' INIT >BODY  BOOT-ADDRESS T!
         T' COLD  BOOT T!

         END.
[cc]
\ ========================================================================
\ S A V E   B I N A R Y  I M A G E   F I L E

         FILENAME$ $SAVE-EA5.            \ FILENAME$ was set by FILENAME:

\ ========================================================================
\  C O P Y   T O   T I - 9 9   V I R T U A L   D I S K
.( copying binary file to TI-99 DSK2.)

( //  shells out to the DOS shell in HSF2012)

      // copy CAMEL99 cc9900\clssic99\dsk2\

CROSS-COMPILING

 CR ." === COMPILE ENDED PROPERLY ==="

   \ BYE          \ exit the cross compiler or stay in to debug
