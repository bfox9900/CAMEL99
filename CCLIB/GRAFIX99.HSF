\ GRAPHICS mode and TI BASIC functions for xfc99 Cross-compiler
\ uses 818 bytes of expansion memory

\ TI-BASIC color values are the machine values + 1
\ CAMEL99 values are the same as TI BASIC
\
\ History:
\ May 22, 2017   Changed GRAPHICS to use transparent charset, 
\                Removed charset coloring from Screen. Much simpler. DUH!
\                Remove sprite table references from this file. Move to Sprites.fth

\ Code Color  (same as TI BASIC for ease of converts to Forth)
\  1   Transparent    9    Medium Red
\  2   Black         10    Light Red
\  3   Medium Green  11    Dark Yellow
\  4   Light Green   12    Light Yellow
\  5   Dark Blue     13    Dark Red
\  6   Light Blue    14    Magenta
\  7   Dark Red      15    Gray
\  8   Cyan          16    White
\

[CC] HEX

TARGET-COMPILING
\ ==============================================================
\ DEFINE VDP TABLES AS ARRAYS
\ **************************************************************

 0380 CONSTANT: CTAB      \ VDP address of the COLOUR TABLE(HEX)
 0800 CONSTANT: PDT       \ VDP address of "PATTERN DESCRIPTOR TABLE"

\ access VDP tables like arrays.  Usage:  9 ]CTAB returns VDP addr
 : ]CTAB  ( set# -- 'ctab[n])   CTAB + ;    \ 1 byte fields
 : ]PDT   ( char# -- 'pdt[n] )  8* PDT + ;  \ 8 byte fields
\ ***************************************************************

( value checking words. They ABORT to Forth with a msg if input is bad)
: ?MODE  ( n -- )      VMODE @ <>   IF T." Mode" ABORT  THEN ;
: ?COLOR ( n -- n )    DUP 16 U>    IF T." color#" ABORT THEN ;
: ?SCR   ( vdpadr -- ) C/SCR @ CHAR+ > IF T." screen adr" ABORT THEN  ;

(  TI hardware needs colors combined into 1 byte. This word does it)
\ : >BYTE  ( nibble nibble -- byte ) 04 LSHIFT + ;  ( used once)

( takes fg nibble, bg nibble, convert to TI hardware #s)
( test for legal values, and combine into 1 byte)
: >COLR ( fg bg -- byte) 1- ?COLOR SWAP 1- ?COLOR  04 LSHIFT + ;

CROSS-ASSEMBLING
CODE: >VPOS ( col row -- VPOS) \ C/L@ * + ; calc VDP address from row & col
            TOS R3 MOV,
           _C/L @@ R3 MPY,
            *SP+ TOS ADD,
            NEXT,
            END-CODE
            
\ : FUSE   ( byte byte -- word )  >< + ;
CODE: FUSE ( byte byte -- word ) \ FUSE 2 bytes into a 16 bit word
            TOS SWPB,
           *SP+ TOS ADD,
            NEXT,
            END-CODE

TARGET-COMPILING
( HEX" converts a string into [CC] HEX [TC] numbers and returns to DECIMAL radix)
: HEX"  ( -- <text>)   HEX T[CHAR] " PARSE EVALUATE DECIMAL   ;

( BIN" converts a binary number string onto the stack returns to DECIMAL radix)
: BIN"  ( -- <text>)  2 BASE ! T[CHAR] " PARSE EVALUATE DECIMAL   ;

\ ==============================================================
\ 4 cell fetch and store to/from VDP RAM
( this version is 12 bytes smaller and almost as fast as using >R R@ etc.)

: 4V!     ( u u u u VDP-addr --)
          6 + TUCK V!
          2-  TUCK V!
          2-  TUCK V!
          2-       V! ;        \ 30 bytes   462uS

: 4V@    ( VDP-addr -- )
          DUP V@
          SWAP CELL+ DUP V@
          SWAP CELL+ DUP V@
          SWAP CELL+ V@ ;         \ 30 BYTES 387uS 

TARGET-COMPILING
( =============================================================)
( T I - B A S I C   S U B - P R O G R A M S   B E G I N )

: CLEAR  ( -- )  PAGE  0 17 AT-XY  ;   ( just because you love it )

( -------------------------------------------------------------)
( COLOR is bigger than in TI-BASIC)
( The hardware supports 255 characters 127 not just 32.. 159 =127)
( *Please* look over the new Set numbers vs BASIC)

(  Char. Code  Forth Set#  Basic Set# )
(  ----------  ----------  ---------- )
(    0-7          0        N/A )
(    8-15         1        N/A )
(   16-23         2        N/A )
(   24-31         3        N/A )
(   32-39         4         1  )
(   40-47         5         2  )
(   48-55         6         3  )
(   56-63         7         4  )
(   64-71         8         5  )
(   72-79         9         6  )
(   80-87        10         7  )
(   88-95        11         8  )
(   96-103       12         9  )
(  104-111       13        10  )
(  112-119       14        11  )
(  120-127       15        12  )
(  128-135       16        13  )
(  136-143       17        14  )
(  144-151       18        15  )
(  152-159       19        16  )
\ -------------------------------

: COLOR  ( character-set fg-color bg-color    -- )
          1 ?MODE  >COLR SWAP ]CTAB  VC! ;

( *NEW* )
( given an ascii value function returns the character set no. )
( no need to remember the color set# Yay!)
: SET#  ( ascii -- set#) 3 RSHIFT ;     ( usage:  CHAR A SET# 2 8 COLOR)

( *NEW*  change contiguous character sets at once)
: COLORS  ( set1 set2 fg bg  -- )
          1 ?MODE
          >COLR >R
          SWAP ]CTAB SWAP ]CTAB OVER - R> VFILL ;

: SCREEN ( color -- )
         1 ?MODE                \ check for MODE 1
         1- ?COLOR              \ convert TI-BASIC color to VDP color and test if valid
 ( -- n) 7 VWTR  ;              \ set screen colour in Video register 7

( NOT like TI-BASIC: Changes to familiar CYAN screen)
: GRAPHICS  ( -- )
             1 VMODE !          \ call this video mode 1
             0 380  0 VFILL     \ erase the entire 40 col. screen space
             20 C/L!            \ 32 chars/line
             E0 DUP KTP C!      \ KSCAN re-writes VDP Reg1 with this byte
      ( -- E0) 1 VWTR           \ VDP register 1  bit3 = 0 = Graphics Mode
             1 6 VWTR           \ set sprite descriptor table to 1x$800=$800
             CTAB 10 10 VFILL   \ set ASCII chars to black on transparent [1,0]
             8 SCREEN
             CLEAR ;            \ cyan SCREEN

\ CHAR sub-program is renamed to CHARDEF
\ USAGE: HEX" 7C7C 7C7C 7C7C 7C00" 30 CHARDEF

: CHARDEF  ( FFFF FFFF FFFF FFFF char# --)  ]PDT 4V! ;   \ TI BASIC CALL CHAR
: CHARPAT  ( char# -- FFFF FFFF FFFF FFFF)  ]PDT 4V@ ;   \ TI BASIC CALL PATTERN

: GCHAR ( row col -- char)  >VPOS VC@ ;

( ** NOTE: for HCHAR & VCHAR you must give the number of repetitions )
: HCHAR  ( col row char cnt -- ) \ parameter order not ideal so we shuffle
          SWAP >R >R         \ swap char & cnt, push to return stack
          >VPOS              \ -- vadr )
          R>  2DUP + ?SCR    \ bring back count add to Vadr and see if it's too many
          R>  VFILL ;        \ bring back char and FILL Video memory

: VCHAR  ( x y char cnt -- ) \ parameter order not ideal so we shuffle
          >R >R              \ ( -- x y )  push char & cnt to rstack
          >VPOS              \ ( -- vdpaddr) calc the Video position in memory
          C/SCR @ 1- SWAP    \ ( -- lim vdpaddr) End of screen - 1, is the Video Limit
          R> SWAP            \ ( -- lim char vadr) get the char and reverse order
          R> 0               \ ( -- lim char vadr cnt index) all that crap to get this
          ?DO                \ ( -- lim char vadr)  let 'er rip
             PAUSE           \ mult-tasking friendly
             2DUP VC!        \ write char to video memory)
             C/L@ +  VCLIP   \ clip vadr to lim value (CODE word for speed)
          LOOP
          2DROP DROP ;

\ high speed routines to support SPRITES
CROSS-ASSEMBLING
CODE: DXY ( x2 y2 x1 y1 --- x^2 y^2 )
          *SP+ R0 MOV,      \ x1->R0
          *SP+ TOS SUB,     \ y1-y2->tos
          *SP  R0 SUB,      \ x1-x2->R0
           TOS R3 MOV,      \ dup tos in r3, MPY goes into R4 for free!
           TOS R3 MPY,      \ r3^2, result->r4 (tos)
           R0  R2  MOV,     \ dup R0
           R2  R0  MPY,     \ RO^2
           R1 *SP  MOV,     \ result to stack
           NEXT,            \ 16 bytes
           END-CODE

CODE: VECT+ ( x y dx dy -- yyxx )  \ Compute new sprite location
           *SP+ R0 MOV,   \ vx->R0
           *SP+ TOS ADD,  \ y + dy ->TOS
           *SP+ R0  ADD,  \ x + dx ->RO
            TOS SWPB,
            R0 TOS ADD,   \ combine bytes into 16 bit XY sprite location
            NEXT,
            END-CODE

CODE: 2(X^2) ( x -- x')
            TOS R3 MOV,       \ dup X
            TOS R3 MPY,       \ X * X ->R4 (TOS = X^2)
            TOS TOS ADD,      \ faster to add for 2 times
            NEXT,
            END-CODE

TARGET-COMPILING